<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>free audiobook maker — wasm tts + ai horde</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { --bg:#0b0f14; --panel:#111826; --muted:#97a3b6; --text:#e7eefc; --accent:#65b3ff; }
    *{box-sizing:border-box}
    body{margin:0;background:linear-gradient(180deg,#0b0f14,#0a0d12);color:var(--text);font:16px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial}
    header{padding:20px 16px;border-bottom:1px solid #162033}
    h1{margin:0;font-size:20px}
    .wrap{max-width:1200px;margin:0 auto;padding:16px;display:grid;gap:16px;grid-template-columns:1.2fr .8fr}
    @media (max-width: 980px){ .wrap{grid-template-columns:1fr} }
    .card{background:var(--panel);border:1px solid #162033;border-radius:14px;padding:14px}
    label{display:block;font-size:13px;color:var(--muted);margin:8px 0 4px}
    textarea,input,select{width:100%;background:#0c141f;color:var(--text);border:1px solid #1b2b46;border-radius:10px;padding:10px 12px}
    textarea{min-height:140px;resize:vertical}
    button{background:#17365d;color:#e7eefc;border:none;border-radius:12px;padding:10px 14px;cursor:pointer}
    button:hover{filter:brightness(1.08)}
    .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    .muted{color:var(--muted);font-size:13px}
    .status{font-size:13px;color:var(--accent)}
    .history-item{padding:10px;border:1px solid #1b2b46;border-radius:12px;margin:10px 0}
    .title-line{display:flex;justify-content:space-between;gap:10px;align-items:center}
    .story{white-space:pre-wrap;background:#0c141f;border:1px solid #1b2b46;border-radius:10px;padding:10px;margin-top:8px;max-height:240px;overflow:auto}
    .pill{font-size:12px;color:#9ecbff;background:#14253e;border:1px solid #214770;border-radius:999px;padding:2px 8px}
    .small{font-size:12px}
    .audio-row{display:flex;gap:8px;align-items:center;margin-top:8px}
    .progress{height:6px;background:#0c141f;border:1px solid #1b2b46;border-radius:999px;overflow:hidden}
    .bar{height:100%;width:0;background:linear-gradient(90deg,#5fa8ff,#86ffd8)}
    .danger{background:#3a1111;border-color:#5b1a1a}
    .grid{display:grid;gap:10px;grid-template-columns:1fr 1fr}
    @media (max-width: 640px){ .grid{grid-template-columns:1fr} }
  </style>
</head>
<body>
  <header>
    <h1>free audiobook maker (wasm tts + ai horde)</h1>
    <div class="muted">real story writing via <b>AI Horde</b> (free, no key). audio via <b>WASM TTS</b> you already set up.</div>
  </header>

  <div class="wrap">
    <section class="card">
      <div class="row">
        <div class="pill">ai horde • wasm tts</div>
        <div id="status" class="status">idle.</div>
      </div>

      <div class="grid">
        <div>
          <label for="prompt">your idea</label>
          <textarea id="prompt" placeholder="e.g., a ww1 survivor recounts the trenches and returning home"></textarea>
        </div>
        <div>
          <label for="minutes">target length (minutes)</label>
          <!-- custom minutes (any value) -->
          <input id="minutes" type="number" min="1" max="180" value="15" />
          <label for="wpm">reading pace (words/min)</label>
          <input id="wpm" type="number" value="150" min="110" max="200" />
        </div>
      </div>

      <div class="row" style="margin-top:8px">
        <button id="genBtn">generate story (free ai)</button>
        <button id="cancelBtn" class="danger">cancel</button>
        <div class="muted">requests ~minutes × WPM words</div>
      </div>

      <div class="progress" style="margin:10px 0 6px"><div id="prog" class="bar"></div></div>

      <label for="story" style="margin-top:6px">story draft (editable)</label>
      <textarea id="story" placeholder="the ai story will appear here. edit freely before audio. "></textarea>

      <hr style="border:none;height:1px;background:#162033;margin:14px 0" />

      <!-- voice ui (still here; mms-tts-eng is single-voice but we keep UI for later swaps) -->
      <div class="grid">
        <div>
          <label for="voiceMode">voice mode</label>
          <select id="voiceMode">
            <option value="manual" selected>manual</option>
          </select>
        </div>
        <div id="manualBox">
          <label for="voiceProfile">voice profile</label>
          <select id="voiceProfile">
            <option value="narrator" selected>narrator (mms-tts-eng)</option>
          </select>
          <div class="row">
            <button id="previewBtn">preview voice</button>
            <span class="muted" style="font-size:12px">sample: “the winter of 1917 never left me.”</span>
          </div>
        </div>
      </div>

      <div class="row" style="margin-top:8px">
        <button id="ttsBtn">make audio</button>
        <button id="stopTtsBtn" class="danger">stop audio</button>
        <button id="downloadBtn">download mp3</button>
      </div>

      <div class="audio-row">
        <audio id="player" controls style="width:100%"></audio>
      </div>
      <div class="progress" style="margin-top:8px"><div id="ttsProg" class="bar"></div></div>
    </section>

    <aside class="card">
      <div class="pill">notes</div>
      <ul class="muted">
        <li>AI Horde is free and anonymous; queues can take a bit when busy.</li>
        <li>WASM TTS model: <b>Xenova/mms-tts-eng</b> (small, loads on most devices).</li>
        <li>If you later want expressive voices, we can add Bark again, but Hugging Face sometimes requires auth.</li>
      </ul>
    </aside>
  </div>

  <script type="module">
    import { pipeline } from "./lib/transformers.min.js";
    import "https://cdn.jsdelivr.net/npm/lamejs@1.2.1/lame.min.js";

    // ---------- elements ----------
    const $ = id => document.getElementById(id);
    const statusEl = $("status"), progEl = $("prog"), ttsProg = $("ttsProg");
    const promptEl = $("prompt"), minutesEl = $("minutes"), wpmEl = $("wpm");
    const storyEl = $("story"), player = $("player");
    const genBtn = $("genBtn"), cancelBtn = $("cancelBtn");
    const ttsBtn = $("ttsBtn"), stopTtsBtn = $("stopTtsBtn"), downloadBtn = $("downloadBtn");
    const previewBtn = $("previewBtn"), voiceProfileEl = $("voiceProfile");

    // ---------- WASM TTS (single model to avoid HF auth issues) ----------
    let ttsPipe = null;         // text-to-speech pipeline
    let lastAudio = null;       // Float32Array
    let lastRate = 24000;

    statusEl.textContent = "loading speech (wasm)…";
    (async () => {
      try {
        ttsPipe = await pipeline("text-to-speech", "Xenova/mms-tts-eng", { device: "wasm" });
        statusEl.textContent = "speech ready (wasm).";
      } catch (e) {
        console.warn("tts load failed; audio buttons will still bind", e);
        statusEl.textContent = "speech offline (will retry on first use)";
      }
    })();

    async function ensureTTS(){
      if (ttsPipe) return;
      statusEl.textContent = "loading speech (wasm)…";
      ttsPipe = await pipeline("text-to-speech", "Xenova/mms-tts-eng", { device: "wasm" });
      statusEl.textContent = "speech ready (wasm).";
    }

    // ---------- AI Horde text generation ----------
    const HORDE_HEADERS = {
      "Content-Type": "application/json",
      "Client-Agent": "audiobook-maker:0.1 (github pages demo)",
      "apikey": "0000000000" // guest key
    };
    let cancelPoll = false;

    function buildAIPrompt(idea, minutes, wpm){
      const targetWords = Math.max(120, Math.min(12000, Math.floor(minutes * wpm)));
      return [
        "You are a skilled long-form narrator.",
        "Write a coherent first-person story with clear beginning, middle, and end.",
        `Target length: about ${targetWords} words.`,
        `Topic: ${idea}`,
        "Do not include disclaimers, notes, or markdown — only the story text."
      ].join("\n");
    }

    async function hordeQueue(prompt){
      const proxy = "https://cors-anywhere.herokuapp.com/";
      const res = await fetch(proxy + "https://aihorde.net/api/v2/generate/text", {
        method: "POST",
        headers: HORDE_HEADERS,
        body: JSON.stringify({
          prompt,
          params: {
            temperature: 0.9,
            max_length: 1200,   // enough for ~700-900 words per pass
            top_p: 0.92,
            top_k: 0,
            typical: 1,
            rep_pen: 1.1,
            stop_sequence: ["###","</s>"]
          },
          models: [] // let horde pick an available model
        })
      });
      if (!res.ok) throw new Error("queue failed: " + res.status);
      const j = await res.json();
      return j.id;
    }

    async function hordePoll(id){
      cancelPoll = false;
      while(!cancelPoll){
        const r = await fetch(proxy + `https://aihorde.net/api/v2/generate/text/status/${id}`, {
          headers: { "Client-Agent": "audiobook-maker:0.1" }
        });
        if (!r.ok) throw new Error("status " + r.status);
        const j = await r.json();
        const p = Math.floor(((j?.state?.progress ?? 0) * 100));
        progEl.style.width = `${Math.min(100, p)}%`;
        if ((j.generations && j.generations.length) || j?.state?.done || j?.state?.finished) {
          return (j.generations?.[0]?.text || "").trim();
        }
        await new Promise(res => setTimeout(res, 1500));
      }
      throw new Error("cancelled");
    }

    genBtn.onclick = async () => {
      const idea = promptEl.value.trim();
      if (!idea) return alert("type your idea first");
      progEl.style.width = "0%";
      statusEl.textContent = "queuing on AI Horde…";
      try {
        const jobPrompt = buildAIPrompt(idea, +minutesEl.value, +wpmEl.value);
        const id = await hordeQueue(jobPrompt);
        statusEl.textContent = "waiting in queue…";
        const text = await hordePoll(id);
        if (!text) throw new Error("empty response");
        storyEl.value = text;
        statusEl.textContent = "story ready.";
        progEl.style.width = "100%";
      } catch (e) {
        console.error(e);
        if (e.message === "cancelled") {
          statusEl.textContent = "cancelled.";
        } else {
          statusEl.textContent = "failed to generate (horde). try again.";
        }
      }
    };
    cancelBtn.onclick = () => { cancelPoll = true; };

    // ---------- PCM/WAV/MP3 helpers ----------
    function floatTo16BitPCM(float32){
      const buf=new ArrayBuffer(float32.length*2), view=new DataView(buf);
      for(let i=0;i<float32.length;i++){ let s=Math.max(-1,Math.min(1,float32[i])); view.setInt16(i*2, s<0?s*0x8000:s*0x7FFF, true); }
      return new Int16Array(buf);
    }
    function makeWavBlob(float32, sampleRate){
      const pcm16=floatTo16BitPCM(float32);
      const wavBytes=44+pcm16.length*2; const buf=new ArrayBuffer(wavBytes); const view=new DataView(buf);
      let off=0; const w=s=>{ for(let i=0;i<s.length;i++) view.setUint8(off++, s.charCodeAt(i)); };
      w('RIFF'); view.setUint32(off,36+pcm16.length*2,true); off+=4; w('WAVEfmt '); view.setUint32(off,16,true); off+=4;
      view.setUint16(off,1,true); off+=2; view.setUint16(off,1,true); off+=2; view.setUint32(off,sampleRate,true); off+=4;
      view.setUint32(off,sampleRate*2,true); off+=4; view.setUint16(off,2,true); off+=2; view.setUint16(off,16,true); off+=2; w('data');
      view.setUint32(off, pcm16.length*2, true); off+=4; new Int16Array(buf,44).set(pcm16); return new Blob([buf],{type:"audio/wav"});
    }

    async function speak(text){
      await ensureTTS();
      const sents = text.replace(/\s+/g,' ').match(/[^.!?]+[.!?]+|\S+$/g) || [text];
      const chunks=[]; let total=0;
      ttsProg.style.width = "0%";
      for (let i=0;i<sents.length;i++){
        const part = sents[i].trim(); if(!part) continue;
        const out = await ttsPipe(part, { language: "en" });
        const pcm = out.audio instanceof Float32Array ? out.audio : new Float32Array(out.audio);
        lastRate = out.sampling_rate || 24000;
        chunks.push(pcm); total += pcm.length;
        ttsProg.style.width = `${Math.min(100, Math.round(((i+1)/sents.length)*100))}%`;
        await new Promise(r=>setTimeout(r,0));
      }
      const merged = new Float32Array(total);
      let off = 0; for (const c of chunks){ merged.set(c, off); off += c.length; }
      lastAudio = merged;
      const wav = makeWavBlob(merged, lastRate);
      player.src = URL.createObjectURL(wav);
      player.play().catch(()=>{});
    }

    // ---------- buttons ----------
    previewBtn.onclick = async () => {
      try { await speak("the winter of 1917 never left me."); }
      catch (e) { console.error(e); alert("speech engine failed to load. try refresh."); }
    };

    ttsBtn.onclick = async () => {
      const text = storyEl.value.trim();
      if (!text) return alert("no story to read");
      try { await speak(text); }
      catch (e) { console.error(e); alert("speech failed. refresh and try again."); }
    };

    stopTtsBtn.onclick = () => { player.pause(); };

    downloadBtn.onclick = () => {
      if (!lastAudio) return alert("nothing to download yet");
      // encode to mp3 using lamejs (CORS-safe script include)
      const pcm16 = floatTo16BitPCM(lastAudio);
      const samples = Array.from(pcm16);
      const mp3enc = new lamejs.Mp3Encoder(1, lastRate, 128);
      const chunk = 1152; const mp3=[];
      for(let i=0;i<samples.length;i+=chunk){
        const buf = mp3enc.encodeBuffer(samples.slice(i,i+chunk));
        if(buf.length) mp3.push(buf);
      }
      const end = mp3enc.flush(); if(end.length) mp3.push(end);
      const blob=new Blob(mp3,{type:"audio/mpeg"});
      const a=Object.assign(document.createElement("a"),{href:URL.createObjectURL(blob),download:"story.mp3"}); a.click();
    };
  </script>
</body>
</html>
