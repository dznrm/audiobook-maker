<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>free audiobook maker — works anywhere (wasm tts, optional ai)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { --bg:#0b0f14; --panel:#111826; --muted:#97a3b6; --text:#e7eefc; --accent:#65b3ff; }
    *{box-sizing:border-box}
    body{margin:0;background:linear-gradient(180deg,#0b0f14,#0a0d12);color:var(--text);font:16px/1.45 system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial}
    header{padding:20px 16px;border-bottom:1px solid #162033}
    h1{margin:0;font-size:20px}
    .wrap{max-width:1200px;margin:0 auto;padding:16px;display:grid;gap:16px;grid-template-columns:1.2fr .8fr}
    @media (max-width: 980px){ .wrap{grid-template-columns:1fr} }
    .card{background:var(--panel);border:1px solid #162033;border-radius:14px;padding:14px}
    label{display:block;font-size:13px;color:var(--muted);margin:8px 0 4px}
    textarea,input,select{width:100%;background:#0c141f;color:var(--text);border:1px solid #1b2b46;border-radius:10px;padding:10px 12px}
    textarea{min-height:140px;resize:vertical}
    button{background:#17365d;color:#e7eefc;border:none;border-radius:12px;padding:10px 14px;cursor:pointer}
    button:hover{filter:brightness(1.08)}
    .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    .muted{color:var(--muted);font-size:13px}
    .status{font-size:13px;color:var(--accent)}
    .history-item{padding:10px;border:1px solid #1b2b46;border-radius:12px;margin:10px 0}
    .title-line{display:flex;justify-content:space-between;gap:10px;align-items:center}
    .story{white-space:pre-wrap;background:#0c141f;border:1px solid #1b2b46;border-radius:10px;padding:10px;margin-top:8px;max-height:240px;overflow:auto}
    .pill{font-size:12px;color:#9ecbff;background:#14253e;border:1px solid #214770;border-radius:999px;padding:2px 8px}
    .small{font-size:12px}
    .audio-row{display:flex;gap:8px;align-items:center;margin-top:8px}
    .progress{height:6px;background:#0c141f;border:1px solid #1b2b46;border-radius:999px;overflow:hidden}
    .bar{height:100%;width:0;background:linear-gradient(90deg,#5fa8ff,#86ffd8)}
    .notice{font-size:12px;color:var(--muted)}
    .danger{background:#3a1111;border-color:#5b1a1a}
    .grid{display:grid;gap:10px;grid-template-columns:1fr 1fr}
    @media (max-width: 640px){ .grid{grid-template-columns:1fr} }
    .subtle{opacity:.85}
    .kbd{font-size:12px;background:#0c141f;border:1px solid #1b2b46;border-radius:6px;padding:2px 6px}
    .tag{font-size:11px;padding:2px 6px;border:1px solid #2a4066;border-radius:999px;background:#12213a;color:#9ecbff}
  </style>
</head>
<body>
<header>
  <h1>free audiobook maker (wasm tts • optional ai) — works on desktop & mobile</h1>
  <div class="muted">no keys, no servers. speech is generated locally with <strong>wasm</strong> (not webgpu). optional ai text-gen turns on where supported; otherwise a solid offline generator handles it.</div>
</header>

<div class="wrap">
  <!-- left: composer -->
  <section class="card">
    <div class="row">
      <div class="pill">offline • wasm tts</div>
      <div id="status" class="status">loading speech engine… first run downloads a small model</div>
    </div>

    <div class="grid">
      <div>
        <label for="prompt">your idea</label>
        <textarea id="prompt" placeholder="e.g., a ww1 survivor recounts the trenches and returning home"></textarea>
      </div>
      <div>
        <label for="minutes">target length (minutes)</label>
        <select id="minutes"><option>5</option><option selected>10</option><option>15</option><option>20</option><option>30</option></select>
        <label for="wpm">reading pace (words/min)</label>
        <input id="wpm" type="number" value="150" min="110" max="190" />
      </div>
    </div>

    <div class="row" style="margin-top:8px">
      <span class="tag">generator</span>
      <select id="genMode">
        <option value="auto" selected>auto (try AI, else fallback)</option>
        <option value="ai">ai (experimental)</option>
        <option value="fallback">fallback (fastest, always works)</option>
      </select>
      <button id="genBtn">generate story</button>
      <button id="stopGenBtn" class="danger">stop</button>
    </div>

    <label for="story" style="margin-top:10px">story draft (editable)</label>
    <textarea id="story" placeholder="your generated story will appear here. you can tweak it before audio."></textarea>

    <hr class="subtle" style="border:none;height:1px;background:#162033;margin:14px 0" />

    <!-- voice controls -->
    <div class="grid">
      <div>
        <label for="voiceMode">voice mode</label>
        <select id="voiceMode">
          <option value="dynamic" selected>dynamic (auto-pick)</option>
          <option value="manual">manual select</option>
        </select>
      </div>
      <div id="manualBox">
        <label for="voiceProfile">voice profile</label>
        <select id="voiceProfile"></select>
        <div class="row">
          <button id="previewBtn">preview voice</button>
          <span class="muted">sample: “the winter of 1917 never left me.”</span>
        </div>
      </div>
    </div>

    <div class="row" style="margin-top:8px">
      <button id="ttsBtn">make audio</button>
      <button id="stopTtsBtn" class="danger">stop audio</button>
      <button id="downloadBtn">download mp3</button>
      <span class="muted" id="compatNote"></span>
    </div>

    <div class="audio-row">
      <audio id="player" controls style="width:100%"></audio>
    </div>
    <div class="progress" style="margin-top:8px"><div id="prog" class="bar"></div></div>
    <div class="notice" id="note">tip: first run stores models in your browser cache. <span class="kbd">shift+enter</span> = line break.</div>
  </section>

  <!-- right: history -->
  <aside class="card">
    <div class="row" style="justify-content:space-between">
      <div class="pill">history</div>
      <div class="row">
        <button id="exportAll">export all (.json)</button>
        <button id="clearAll" class="danger">clear all</button>
      </div>
    </div>
    <div id="historyList"></div>
  </aside>
</div>

<!-- scripts -->
<script type="module">
/*
  GOALS:
  - Works on virtually all modern browsers (desktop + mobile).
  - No WebGPU required. Uses WASM TTS via transformers.js (onnx runtime web).
  - Optional AI text-gen (tries to load web-llm via esm.sh). If it can't, we fall back to a decent offline generator.
  - Download MP3 (lamejs), voice preview, dynamic voice choice, history cache.
*/

// SAFE, CORS-FRIENDLY IMPORTS
import { pipeline } from "https://esm.sh/@xenova/transformers@3.0.0";
import "https://cdn.jsdelivr.net/npm/lamejs@1.2.1/lame.min.js";

// OPTIONAL: try to load web-llm (if it fails, we just ignore and use fallback generator)
let webllmEngine = null;
(async () => {
  if (document.getElementById('genMode').value === 'fallback') return;
  try {
    const webllm = await import("https://esm.sh/@mlc-ai/web-llm");
    webllmEngine = new webllm.MLCEngine();
    // try small model; set a timeout so it never hangs forever
    const reload = webllmEngine.reload({ model: "Llama-3.2-1B-instruct-q4f32_1-MLC" });
    await Promise.race([
      reload,
      new Promise((_, rej) => setTimeout(()=>rej(new Error("ai init timeout")), 20000))
    ]);
    console.log("ai engine ready");
  } catch (e) {
    console.log("ai engine not available, using fallback generator.", e);
    webllmEngine = null;
  }
})();

const $ = id => document.getElementById(id);

// UI refs
const statusEl = $("status"), progEl = $("prog"), noteEl = $("note"), compatNote = $("compatNote");
const promptEl = $("prompt"), minutesEl = $("minutes"), wpmEl = $("wpm");
const storyEl = $("story"), player = $("player");
const genBtn = $("genBtn"), stopGenBtn = $("stopGenBtn");
const ttsBtn = $("ttsBtn"), stopTtsBtn = $("stopTtsBtn"), downloadBtn = $("downloadBtn");
const exportAllBtn = $("exportAll"), clearAllBtn = $("clearAll"), historyList = $("historyList");
const voiceModeEl = $("voiceMode"), voiceProfileEl = $("voiceProfile"), previewBtn = $("previewBtn"), manualBox = $("manualBox");
const genModeEl = $("genMode");

// GLOBAL STATE
let ttsOute = null;    // primary WASM TTS (multi-speaker)
let ttsBark = null;    // optional expressive TTS (WASM) — lazy loaded on demand
let ttsBusy = false;
let stopGen = false;
let wavPCM = null, wavRate = 24000;

// ENV CHECKS / COMPAT
const hasAudioWorklet = !!(window.AudioWorklet && (window.AudioContext || window.webkitAudioContext));
if (!hasAudioWorklet) compatNote.textContent = "note: audio worklet not available, playback still OK.";
// transformers.js will auto-pick wasm backend; no WebGPU needed
statusEl.textContent = "loading speech engine (wasm)…";

// VOICE PROFILES (broad set mapped to two models)
const VOICES = [
  { id:"old-man-1",   name:"old man (expressive, bark)",     model:"bark", preset:"v2/en_speaker_6" },
  { id:"old-man-2",   name:"old man (calm, multi)",          model:"oute", speaker:2 },
  { id:"narrator",    name:"narrator (neutral, multi)",      model:"oute", speaker:0 },
  { id:"young-man-1", name:"young man (bark)",               model:"bark", preset:"v2/en_speaker_3" },
  { id:"young-man-2", name:"young man (multi)",              model:"oute", speaker:1 },
  { id:"boy",         name:"boy (light, bark)",              model:"bark", preset:"v2/en_speaker_9" },
  { id:"woman-1",     name:"woman (warm, multi)",            model:"oute", speaker:3 },
  { id:"woman-2",     name:"woman (expressive, bark)",       model:"bark", preset:"v2/en_speaker_1" },
  { id:"uk-narrator", name:"narrator (uk vibe, bark)",       model:"bark", preset:"v2/en_speaker_8" },
  { id:"soft-elder",  name:"elder soft (multi)",             model:"oute", speaker:4 },
  { id:"radio-host",  name:"radio host (bark)",              model:"bark", preset:"v2/en_speaker_7" },
  { id:"storyteller", name:"storyteller (deep, bark)",       model:"bark", preset:"v2/en_speaker_5" },
];
function loadVoiceDropdown(){
  voiceProfileEl.innerHTML = VOICES.map(v=>`<option value="${v.id}">${v.name}</option>`).join("");
}
loadVoiceDropdown();

// manual UI visible to allow preview even in dynamic mode
manualBox.style.display = "block";

// INIT TTS (WASM)
initTTS().then(()=> {
  statusEl.textContent = "speech ready (wasm).";
  noteEl.textContent = "models cached locally. next runs are faster.";
}).catch(e=>{
  console.error(e);
  statusEl.textContent = "failed to init TTS (wasm). refresh or try another browser.";
});

async function initTTS() {
  // Always load OuteTTS (smaller, neutral multi-speaker)
  ttsOute = await pipeline("text-to-speech", "onnx-community/OuteTTS-0.2-500M", {
    device: "wasm" // cross-browser
  });
  // Bark is heavier; lazy-load when a Bark voice is requested
}

// HISTORY
function ts(){ return new Date().toISOString(); }
function titleFromPrompt(p){ return (p||"untitled").slice(0,80).trim() || "untitled"; }
function saveHistory(item){
  const k = "audiobook_hist_v3";
  const arr = JSON.parse(localStorage.getItem(k)||"[]");
  arr.unshift(item);
  localStorage.setItem(k, JSON.stringify(arr.slice(0,300)));
  renderHistory();
}
function delHistory(idx){
  const k = "audiobook_hist_v3";
  const arr = JSON.parse(localStorage.getItem(k)||"[]");
  arr.splice(idx,1);
  localStorage.setItem(k, JSON.stringify(arr));
  renderHistory();
}
function renderHistory(){
  const arr = JSON.parse(localStorage.getItem("audiobook_hist_v3")||"[]");
  historyList.innerHTML = arr.length ? arr.map((x,i)=>`
    <div class="history-item">
      <div class="title-line">
        <div>
          <div class="small">${new Date(x.date).toLocaleString()}</div>
          <strong>${x.title}</strong>
          <div class="small muted">${x.voiceName || "—"}</div>
        </div>
        <div class="row">
          <button data-act="load" data-idx="${i}">load</button>
          <button data-act="delete" data-idx="${i}" class="danger">delete</button>
        </div>
      </div>
      <div class="story small">${x.text.slice(0,400)}${x.text.length>400?'…':''}</div>
    </div>
  `).join("") : `<div class="muted">no items yet.</div>`;
}
renderHistory();
historyList.addEventListener("click", (e)=>{
  const btn = e.target.closest("button"); if(!btn) return;
  const act = btn.dataset.act, idx = +btn.dataset.idx;
  const arr = JSON.parse(localStorage.getItem("audiobook_hist_v3")||"[]");
  if(act==="delete"){ delHistory(idx); return; }
  if(act==="load"){ const it = arr[idx]; promptEl.value = it.prompt || ""; storyEl.value = it.text || ""; voiceProfileEl.value = it.voiceId || VOICES[0].id; }
});
clearAllBtn.onclick = ()=>{ if(confirm("clear all history?")){ localStorage.removeItem("audiobook_hist_v3"); renderHistory(); } };
exportAllBtn.onclick = ()=>{
  const data = localStorage.getItem("audiobook_hist_v3")||"[]";
  const blob = new Blob([data], {type:"application/json"});
  const a = Object.assign(document.createElement("a"), { href: URL.createObjectURL(blob), download: "audiobook_history.json" });
  a.click();
};

// GENERATOR HELPERS
function wordsForMinutes(mins, wpm){ return Math.max(120, Math.floor(mins * wpm)); }

// Fallback generator (template-based, coherent paragraphs)
function fallbackGenerate(topic, targetWords){
  const beats = [
    ["opening", 0.18], ["inciting", 0.10], ["rising", 0.18],
    ["climax", 0.18], ["falling", 0.18], ["resolution", 0.18]
  ];
  const total = targetWords;
  let out = [];
  for (const [beat, frac] of beats){
    const words = Math.max(60, Math.floor(total * frac));
    out.push(paragraphFor(beat, topic, words));
  }
  return out.join("\n\n");
}
function paragraphFor(beat, topic, words){
  const hooks = {
    opening:   ["i’ll start where it still hurts:","people remember the headlines, not the mud.","the air had that metallic taste again."],
    inciting:  ["the first real change came with","i didn’t believe the rumors until","the letter arrived at dawn,"],
    rising:    ["days bled together after that.","there was a rhythm to the fear.","we learned to joke with empty stomachs."],
    climax:    ["then came the thing no one trains for.","the world narrowed to breath and heartbeat.","it felt like the sky folded in on itself."],
    falling:   ["when it ended, the silence was heavier than the shelling.","we counted what we had left, and who.","i didn’t sleep so much as drift."],
    resolution:["if there’s any lesson, it’s this:","home is different when you return different.","i keep a small box of things that survived with me."]
  };
  const seed = hooks[beat][Math.floor(Math.random()*hooks[beat].length)];
  // expand with varied sentences aiming roughly for `words`
  const avg = 16; const sentences = Math.max(3, Math.floor(words/avg));
  let p = [seed + " " + riff(topic)];
  for (let i=1;i<sentences;i++) p.push(riff(topic));
  return tidy(p.join(" "));
}
function riff(topic){
  const bits = [
    `the ${topic} wasn’t a story so much as a sequence of small choices.`,
    `someone always kept watch; someone always pretended not to be afraid.`,
    `i remember the smell: oil, damp fabric, and metal shavings.`,
    `we traded rumors like currency, half-hope, half-danger.`,
    `i wrote things down so i wouldn’t forget, then lost the pages anyway.`,
    `names mattered; we said them out loud so they wouldn’t vanish.`,
    `time stretched and then snapped back like a wire.`,
    `you learn which sounds mean run, and which mean breathe.`,
    `we promised to meet after, as if after was guaranteed.`,
    `if courage existed, it looked ordinary and tired.`
  ];
  return bits[Math.floor(Math.random()*bits.length)];
}
function tidy(s){
  return s.replace(/\s+/g," ").replace(/\s([,.!?;:])/g,"$1");
}

// AI voice pick (lightweight heuristic if no AI)
function rulePickVoice(prompt, text){
  const s = `${prompt}\n${text}`.toLowerCase();
  if (/(ww1|war|veteran|trenches|elder|grandfather|old man)/.test(s)) return "old-man-2";
  if (/(narrator|documentary|history|expository)/.test(s)) return "narrator";
  if (/(radio|news|host|show)/.test(s)) return "radio-host";
  if (/(woman|mother|her story|she )/.test(s)) return "woman-1";
  if (/(boy|child|kid)/.test(s)) return "boy";
  if (/(young man|teen|student|he )/.test(s)) return "young-man-2";
  return "narrator";
}
async function aiPickVoice(prompt, text){
  if (!webllmEngine) return rulePickVoice(prompt, text);
  try {
    const query = [
      "Pick exactly one ID for TTS: old-man-1, old-man-2, young-man-1, young-man-2, boy, woman-1, woman-2, narrator, uk-narrator, radio-host, storyteller, soft-elder.",
      "Return ID only.",
      `PROMPT: ${prompt}`,
      `EXCERPT: ${text.slice(0, 700)}`
    ].join("\n");
    const res = await webllmEngine.chat.completions.create({
      messages: [
        {role:"system", content:"You select the best TTS voice ID. Output only the ID."},
        {role:"user", content: query}
      ],
      temperature: 0.2, max_tokens: 8
    });
    const choice = (res?.choices?.[0]?.message?.content || "").trim();
    const valid = VOICES.find(v => v.id === choice);
    return valid ? valid.id : rulePickVoice(prompt, text);
  } catch {
    return rulePickVoice(prompt, text);
  }
}
function getVoiceById(id){ return VOICES.find(v=>v.id===id) || VOICES[0]; }

// STORY GENERATION (auto / ai / fallback)
genBtn.onclick = async ()=>{
  stopGen = false;
  const prompt = promptEl.value.trim();
  if(!prompt){ alert("give me a prompt first"); return; }
  const targetWords = wordsForMinutes(+minutesEl.value, +wpmEl.value);
  storyEl.value = ""; progEl.style.width = "0%";
  let out = "";

  const mode = genModeEl.value;
  statusEl.textContent = (mode==="ai" || (mode==="auto" && webllmEngine)) ? "writing with ai…" : "writing (offline generator)…";

  if (mode==="ai" || (mode==="auto" && webllmEngine)){
    try{
      const sys = [
        "you are a strong long-form storyteller.",
        "first-person if it fits.",
        `target ~${targetWords} words.`,
        "coherent beginning-middle-end; no disclaimers; natural paragraphing."
      ].join("\n");
      const messages = [
        { role:"system", content: sys },
        { role:"user", content: `topic: ${prompt}\nwrite the complete story now.` }
      ];
      const stream = await webllmEngine.chat.completions.create({ messages, stream:true, temperature:0.9, max_tokens: Math.min(4096, targetWords*2) });
      for await (const chunk of stream){
        if (stopGen) break;
        const delta = chunk?.choices?.[0]?.delta?.content || "";
        if (delta){ out += delta; storyEl.value = out; storyEl.scrollTop = storyEl.scrollHeight; }
        const p = Math.min(95, (out.length / (targetWords*6)) * 100);
        progEl.style.width = `${p}%`;
      }
    } catch (e){
      console.log("ai failed, using fallback", e);
      out = fallbackGenerate(prompt, targetWords);
      storyEl.value = out;
    }
  } else {
    out = fallbackGenerate(prompt, targetWords);
    storyEl.value = out;
  }

  progEl.style.width = "100%";
  statusEl.textContent = "story ready.";
  saveHistory({ date: ts(), title: titleFromPrompt(prompt), prompt, text: storyEl.value, voiceId: voiceProfileEl.value, voiceName: getVoiceById(voiceProfileEl.value)?.name });
};
stopGenBtn.onclick = ()=>{ stopGen = true; statusEl.textContent = "stopped."; };

// TTS CORE (WASM)
function splitIntoSentences(text){
  return text.replace(/\s+/g,' ').match(/[^.!?]+[.!?]+|\S+$/g) || [text];
}
async function ensureBark(){
  if (ttsBark) return;
  statusEl.textContent = "loading expressive voice engine (wasm)…";
  ttsBark = await pipeline("text-to-speech", "Xenova/bark-small", { device:"wasm" });
  statusEl.textContent = "speech ready (wasm).";
}

async function runTTSWithVoice(text, voice){
  const sents = splitIntoSentences(text);
  const chunks = []; let mergedLen = 0;
  ttsBusy = true; statusEl.textContent = `synthesizing (${voice.name})…`; progEl.style.width = "0%";

  const useBark = voice.model === "bark";
  if (useBark) await ensureBark();
  const pipe = useBark ? ttsBark : ttsOute;

  for(let i=0;i<sents.length;i++){
    const part = sents[i].trim(); if(!part) continue;
    let res;
    if(useBark){
      res = await pipe(part, { voice_preset: voice.preset || "v2/en_speaker_6" });
    } else {
      res = await pipe(part, { language:"en", speaker_id: (voice.speaker ?? 0) });
    }
    const pcm = res.audio instanceof Float32Array ? res.audio : new Float32Array(res.audio);
    wavRate = res.sampling_rate || 24000;
    chunks.push(pcm); mergedLen += pcm.length;
    progEl.style.width = `${Math.min(100, ((i+1)/sents.length)*100)}%`;
    await new Promise(r=>setTimeout(r,0));
  }
  const merged = new Float32Array(mergedLen);
  let off=0; for (const c of chunks){ merged.set(c, off); off += c.length; }
  wavPCM = merged;
  statusEl.textContent = "audio ready.";
  return { audio: merged, rate: wavRate };
}

// PREVIEW + PLAYBACK + DOWNLOAD
previewBtn.onclick = async ()=>{
  const v = getVoiceById(voiceProfileEl.value);
  await synthAndPlay("the winter of 1917 never left me.", v);
};
async function synthAndPlay(text, voice){
  const { audio, rate } = await runTTSWithVoice(text, voice);
  playPCM(audio, rate);
}
function floatTo16BitPCM(float32){
  const buf = new ArrayBuffer(float32.length * 2);
  const view = new DataView(buf);
  let offset = 0;
  for (let i = 0; i < float32.length; i++, offset += 2) {
    let s = Math.max(-1, Math.min(1, float32[i]));
    view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
  }
  return new Int16Array(buf);
}
function makeWavBlob(float32, sampleRate){
  const pcm16 = floatTo16BitPCM(float32);
  const wavBytes = 44 + pcm16.length * 2;
  const buf = new ArrayBuffer(wavBytes);
  const view = new DataView(buf);
  let off=0; const writeStr=(o,s)=>{ for(let i=0;i<s.length;i++) view.setUint8(o+i, s.charCodeAt(i)); };
  writeStr(off,'RIFF'); off+=4; view.setUint32(off,36+pcm16.length*2,true); off+=4;
  writeStr(off,'WAVE'); off+=4; writeStr(off,'fmt '); off+=4;
  view.setUint32(off,16,true); off+=4; view.setUint16(off,1,true); off+=2;
  view.setUint16(off,1,true); off+=2; view.setUint32(off,sampleRate,true); off+=4;
  view.setUint32(off,sampleRate*2,true); off+=4; view.setUint16(off,2,true); off+=2;
  view.setUint16(off,16,true); off+=2; writeStr(off,'data'); off+=4;
  view.setUint32(off, pcm16.length*2, true); off+=4;
  new Int16Array(buf,44).set(pcm16);
  return new Blob([buf], {type:"audio/wav"});
}
function playPCM(float32, sampleRate){
  const wavBlob = makeWavBlob(float32, sampleRate);
  player.src = URL.createObjectURL(wavBlob);
  player.play().catch(()=>{ /* autoplay might be blocked */ });
}
function downloadMP3(float32, sampleRate, filename="story.mp3"){
  const pcm16 = floatTo16BitPCM(float32);
  const samples = Array.from(pcm16);
  const mp3enc = new lamejs.Mp3Encoder(1, sampleRate, 128);
  const chunk = 1152;
  const mp3 = [];
  for(let i=0;i<samples.length;i+=chunk){
    const buf = mp3enc.encodeBuffer(samples.slice(i, i+chunk));
    if(buf.length) mp3.push(buf);
  }
  const end = mp3enc.flush(); if(end.length) mp3.push(end);
  const blob = new Blob(mp3, {type:"audio/mpeg"});
  const a = Object.assign(document.createElement("a"), { href: URL.createObjectURL(blob), download: filename });
  a.click();
}
downloadBtn.onclick = ()=>{
  if(!wavPCM){ alert("generate audio first"); return; }
  downloadMP3(wavPCM, wavRate, `${titleFromPrompt(promptEl.value)}.mp3`);
};

// MAIN TTS BUTTON
ttsBtn.onclick = async ()=>{
  if(ttsBusy){ return; }
  const text = storyEl.value.trim();
  if(!text){ alert("no story text to read"); return; }
  let voiceId = voiceProfileEl.value;
  if(voiceModeEl.value === "dynamic"){
    voiceId = await aiPickVoice(promptEl.value, text);
    voiceProfileEl.value = voiceId;
  }
  const voice = getVoiceById(voiceId);
  await synthAndPlay(text, voice);
  const item = { date: ts(), title: titleFromPrompt(promptEl.value), prompt: promptEl.value, text, voiceId: voice.id, voiceName: voice.name };
  saveHistory(item);
};

// STOP AUDIO
stopTtsBtn.onclick = ()=>{ player.pause(); };

// UX nicety
promptEl.addEventListener("keydown", (e)=>{
  if(e.key==="Enter" && !e.shiftKey){ e.preventDefault(); genBtn.click(); }
});
</script>
</body>
</html>
